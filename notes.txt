----------
Rewrite config file syntax
----------
<!-- One file per cluster -->
<rewrite>

  <!-- For hostname mapping, etc. -->
  <properties>
    <property name="internal-host-name" value="external-host-name" bidirectional="true"/>
  </property>

  <!-- Must have an interface contract like String invoke( String[] args ) -->
  <functions>
    <function name="" class="" method=""/>
  </function>

  <!-- Must have an interface contract like -->
  <!-- InputStream filter( InputStream stream, String encoding ) -->
  <!-- Reader filter( Reader reader ) -->
  <filters>
    <filter name="" type="text/html" class=""/>
  </filters>

  <ruleset name="NAMENODE.request">
    <rule>
      <match></match>
      <if>
      <set>
      <run>
      <return></return>
   </rule>
    <rule>
      <match></match>
      <build></build>
   </rule>
  </ruleset>
<rewrite>

<gateway>
  <resource>
    <role>NAMENODE</role>
    <source>/namenode/api/v1/{path=**}?{**}</source>
    <target>http://vm.local:50070/webhdfs/v1/{path=**}?{**}</target>
    <filter>
      <role>rewrite</role>
      <class>org.apache.hadoop.gateway.filter.rewrite.api.UrlRewriteServletFilter</class>
      <param>
        <name>request.ruleset</name><value>NAMENODE.request,more</value>
        <name>request.headers</name><value>Location,*</value>
        <name>request.cookies</name><value>hadoop.auth,*</value>
        <name>request.body</name><value>text/html,*</value>

        <!-- Consider params for parts of the request e.g. inbound.url, inbound.headers, outbound.body -->

        <!-- inbound=HDFS.inboud(headers,coookies,body) -->
        <!-- outbound=
      </param>
    </filter>
  </resource>
</gateway>


----------
Deployment (Once we know we need to create a new WAR).
----------
. Given global config
. Given gateway topology
. Create empty WebArchive
. Create empty WebAppDescriptor
. Invoke the Gateway deployment contributor
  . Create empty ClusterConfig
    . Find all ResourceConfigFactory services
    . For each service in gateway topo
      . Find and service's config factory
      . Add created resources configs to gateway config
        Q: How do they know to include as vs ss?
  . Populate the deployment context with the above.
. Find all ClusterDeploymentContributor services
. Invoke each contributor
  .



If the query is empty, never include the ? in the expansion.

Have every URL section support *, **, {*} and {**}.
Have Params include a source enum.
A {*} or {**} in an expansion template will only include params from the same "source.".
Have ** in the authority if there is only one apply to all four parts.
Rethink the way the "extra" was handled.

The source/target below should create a complete copy of the URL.
{*}://{**}/{**}?{**}#{**}
{*}://{**}/{**}?{**}#{**}
Consider having the param name for the {**} shortcuts be things like
{scheme} {host}, {port}, {username}, {password}, {path}, {query}, {fragment} or shorter
{s} {hn} {pn} {un}, {pw}, {p}, {q}, {f}
These might be a good idea because they should be invalid to specify in the syntax because nested {}'s are allowed
to make parsing easier.

Path
  {path}
    Match: {path=*}
    Extract: {path=**}
  {*} - same as *
  {**} - same as **
Query
  {query}
    Match: query={query=**}
    Extract: query={query=**}
  {*}
    Match: *={*=*}
    Extract: query={query=**}
  {**}
    Match: *={*=**}
    Extract: *={*=**}

--- Path param matching ---
1. Path param required [1,1]
Pattern: /path/{param-name}/path

2. Path param optional [0,n]
Pattern: /path/{param-name*}/path

2. Path remainder optional [0,n]
Pattern: /path/{**}

--- Query param matching
1. Query param required [1,1]
 Pattern: /path?name={param-name}
Template: /other-path?other-name={param-name*}

2. Query param optional [0..n]
 Pattern: /path?name={param-name*}
Template: /other-path?other-name={param-name*}

3. Query param remainder [0..n]
 Pattern: /path?{**}

Notes
By default patterns are reluctantly matched
Query parameter ordering is not significant.
Path parameter ordering is a requirement for matching.
This should match anything /{**}?{**}
The should reproduce the input /{**}?{**}
Note: The **'s will only match what isn't specifically consumed.  Therefore for query param matching they must always logically be last.
Note: For {**} path params remember that they are "reluctant". The value *** could be greedy.

Extensions
Could use + to mean [1,n]
Could use ? to mean [0,1]
Could use additional * to mean greedy **, +*, ?*, [1,n]*
